\documentclass{article}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsthm}
\newtheorem*{prop}{Propriété}
\newtheorem*{ddef}{Définition}
\newtheorem{tth}{Théorème}
\title{Projet 1 (C) : Voyageur de commerce}
\author{Alexandre Talon \& Grégoire Beaudoire}
\begin{document}
\maketitle
\tableofcontents
\section*{Introduction}
On a ici réalisé un projet de programmation dans le langage C. Ce projet, qui a duré sept semaines, a été en très grande partie réalisée en monôme par Alexandre Talon.

On étudie le problème problème d'optimisation classique du voyageur de commerce : il s'agit de parcourir une liste de ville donnée et de revenir à la ville de départ
en un chemin de longueur minimale. D'un point de vue plus formel, on peut voir les villes comme étant les sommets d'un graphe, la distance entre deux villes le poids de 
l'arête reliant les sommets correspondant, le problème étant de trouver un cycle hamiltonien de longueur minimale.


Il s'agit en fait d'un problème NP-complet, c'est-à-dire qu'on ne dispose pas d'algorithme le résolvant de manière exacte en un tems polynomial en fonction de la taille
de l'entrée (villes et distances entre chaque paire de villes). On s'intéresse alors à un algorithme résolvant le problème du voyageur de commerce de manière approchée :
on cherche à programmer un algorithme permettant de trouver une tournée passant par toutes les villes imposées par l'utilisateur, le tout en un temps raisonnable et en
fournissant une réponse pas trop éloignée de la réponse optimale.
%note : il faudrait reformuler ce paragraphe, les formules utilisées ressemblent trop au sujet du projet.


Pour y parvenir, il est nécessaire de choisir des structures de données adaptées aux données que l'on va stocker et à la façon dont on les utilise. On cherche
ici à optimiser le temps mis à l'exécution des divers algorithmes, tout en limitant raisonnablement la place occupée par les données en mémoire. On commencera par
décrire ces structures et la façon dont elles sont implémentées. Dans un second temps il sera question des algorithmes à proprement parler utilisés pour résoudre
le problème. On terminera par le choix de l'interface utilisateur.
%Je suis parti sur un truc thématique, on peut faire chronologique si tu veux.

\section{Structures de données}

On utilise dans ce projet deux structures non triviales : d'une part des tas, d'autre part des arbres arbres binaires de recherche équilibrés de type arbres AVL.
\subsection{Tas}
Un tas est un arbre binaire complet vérifiant la propriété suivante : l'étiquette de tout noeud différent de la racine est inférieure à l'étiquette de son père.


%positions des fils par rapport au père, avantages, en pratique.


\subsection{Arbres AVL}
%Pas de sous partie pour insertion et suppression : ce sont des opérations a priori simples et qui rejoignent les arbres binaires de recherche non équilibrés. On peut les mettre en principe, ou ne pas en parler, ou faire une autre sous partie "Opérations basiques".
Les arbres AVL appartiennent à la classe des arbres binaires de recherche. Ils présentent en outre la particularité d'être automatiquement équilibrés, c'est-à-dire :

\begin{ddef}[Arbre équilibré]
Un arbre équilibré est un arbre dans lequel la hauteur des deux sous-arbres d'un noeud diffère d'au plus un.
\end{ddef}

Pour pouvoir définir plus aisément la notion de "différence de hauteur de sous-arbre", on va définir le facteur d'équilibrage :

\begin{ddef}[Facteur d'équilibrage d'un noeud]
Le facteur d'équilibrage d'un noeud est la différence entre la hauteur de son sous-arbre droit et celle de son sous-arbre gauche.
\end{ddef}

Ainsi un arbre équilibré est simplement un arbre dont le facteur d'équilibrage de la racine est compris entre $-1$ et $1$.

Les arbres AVL s'utilisent comme les arbres binaires de recherche, mais on peut également effectuer sur eux les opérations de rééquilibrage. Pour rééquilibrer un arbre déséquilibré, on effectue ce qu'on appelle des rotations. Il convient tout d'abord de remarquer qu'un arbre peut être déséquilibré de deux façons : il peut être "left heavy", c'est-à-dire que sa racine possède un facteur d'équilibrage plus petit que $-2$, ou "right heavy", c'est-à-dire que sa racine possède un facteur d'équilibrage plus grand que $2$. Nous allons commencer par voir comment résoudre ces problèmes par des rotations simples, puis remarquer qu'elles ne suffisent pas dans certains cas où il est obligatoire d'utiliser des rotations doubles.

\subsubsection{Rotations simples}
%Rotations gauches et droites, les deux étant symétriques. Expliquer pourquoi elles ne suffisent pas.

\subsubsection{Rotations doubles}
%Rotations doubles (you don't say). En quoi elles résolvent les problèmes expliqués juste au-dessus. Expliquer pourquoi elles suffisent.

\subsubsection{Algorithme d'équilibrage}
%L'algorithme dans son nid de phrases pour faire joli.

\section{Algorithme de PRIM}

\subsection{Définitions}
%arbre couvrant minimal

\subsection{Algorithme}

\subsection{Implémentation}

\section{Algorithme TSP}

\subsection{Algorithme}

\subsection{Implémentation}

\section{Utilisation}

\subsection{Interface utilisateur; compilation}
%wtf titre
%Comment l'algorithme fonctionne et réagit à l'utilisateur.

\subsection{Complexité}

\section*{Conclusion}



%BIBLIOGRAPHIE





\end{document}
